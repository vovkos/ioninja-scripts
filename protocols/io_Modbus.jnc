//..............................................................................
//
// Modbus RTU/TCP protocol constants and structs
//

import "ui_Color.jnc"
import "crc16.jnc"

namespace io {

//! \addtogroup proto-modbus
//! @{

pragma(Alignment, 1);

//..............................................................................

// Modbus protocol variations

enum ModbusProtocol: uint8_t {
	Rtu,
	Ascii,
	Tcp,
	RtuIp,
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// Modbus node roles

enum ModbusRole: uint8_t {
	Master,
	Slave,
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// Modbus function codes

enum ModbusFunc: uint8_t {
	[ displayName = "Read coils" ]
	ReadCoils                  = 1,

	[ displayName = "Read discrete inputs" ]
	ReadDiscreteInputs         = 2,

	[ displayName = "Read holding registers" ]
	ReadHoldingRegisters       = 3,

	[ displayName = "Read input registers" ]
	ReadInputRegisters         = 4,

	[ displayName = "Write single coil" ]
	WriteSingleCoil            = 5,

	[ displayName = "Write single register" ]
	WriteSingleRegister        = 6,

	[ displayName = "Read exception status" ]
	ReadExceptionStatus	       = 7,

	[ displayName = "Diagnostics" ]
	Diagnostics                = 8,

	[ displayName = "Get comm event counter" ]
	GetCommEventCounter        = 11,

	[ displayName = "Get comm event log" ]
	GetCommEventLog            = 12,

	[ displayName = "Write multiple coils" ]
	WriteMultipleCoils         = 15,

	[ displayName = "Write multiple registers" ]
	WriteMultipleRegisters     = 16,

	[ displayName = "Report server ID" ]
	ReportServerId             = 17,

	[ displayName = "Read file record" ]
	ReadFileRecord             = 20,

	[ displayName = "Write file record" ]
	WriteFileRecord            = 21,

	[ displayName = "Mask write register" ]
	MaskWriteRegister	       = 22,

	[ displayName = "Read/write multiple registers" ]
	ReadWriteMultipleRegisters = 23,

	[ displayName = "Read FIFO queue" ]
	ReadFifoQueue              = 24,

	[ displayName = "Encapsulated interface" ]
	EncapsulatedInterface      = 43,

	[ displayName = "Exception" ]
	ExceptionFlag              = 0x80,
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// exception codes

enum ModbusException: uint8_t {
	[ displayName = "Illegal function" ]
	IllegalFunction         = 1,

	[ displayName = "Illegal data address" ]
	IllegalDataAddress      = 2,

	[ displayName = "Illegal data value" ]
	IllegalDataValue        = 3,

	[ displayName = "Server device failure" ]
	ServerDeviceFailure     = 4,

	[ displayName = "Acknowledge" ]
	Acknowledge             = 5,

	[ displayName = "Server device busy" ]
	ServerDeviceBusy        = 6,

	[ displayName = "Memory parity error" ]
	MemoryParityError       = 8,

	[ displayName = "Gateway path unavailable" ]
	GatewayPathUnavailable  = 10,

	[ displayName = "Gateway device no response" ]
	GatewayDeviceNoResponse = 11,
}

//..............................................................................

// shared attributes for address fields

[
	displayName = "Address",
	formatSpec = "0x%04X"
]
void ModbusAddressAttr;

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// particular function code PDUs

struct ModbusPduHdr {
	[ displayName = "Function" ]
	io.ModbusFunc m_func;
}

struct ModbusReplyPduHdr {
	[
		displayName = "Function",
		displayType = typeof(ModbusFunc)
	]
	uint8_t m_func: 7;

	[
		displayName = "Exception flag",
		displayType = typeof(bool)
	]
	uint8_t m_exceptionFlag: 1;
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// ModbusFunc.Exception (ModbusPduHdr.m_func has ModbusFunc.ExceptionFlag set)

struct ModbusExceptionParams {
	[ displayName = "Exception" ]
	ModbusException m_exception;
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// ModbusFunc.ReadCoils / ReadDiscreteInputs / ReadHoldingRegisters / ReadInputRegisters

struct ModbusReadParams {
	[ @ModbusAddressAttr ]
	bigendian uint16_t m_address;

	[ displayName = "Count" ]
	bigendian uint16_t m_count;
}

struct ModbusReadReplyParams {
	[ displayName = "Size" ]
	uint8_t m_size;

	// followed by read data
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// ModbusFunc.WriteSingleCoil/WriteSingleRegister

struct ModbusWriteSingleParams {
	[ @ModbusAddressAttr ]
	bigendian uint16_t m_address;

	[ displayName = "Value" ]
	bigendian uint16_t m_value;
}

typedef ModbusWriteSingleParams ModbusWriteSingleReplyParams;

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// ModbusFunc.ReadExceptionStatus

struct ModbusReadExceptionStatusReplyParams {
	[ displayName = "Status" ]
	uint8_t m_status;
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// ModbusFunc.GetCommEventCounter

struct ModbusGetCommEventCounterReplyParams {
	[ displayName = "Status" ]
	bigendian uint16_t m_status;

	[ displayName = "Event count" ]
	bigendian uint16_t m_eventCount;
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// ModbusFunc.GetCommEventLog

struct ModbusGetCommEventLogReplyParams: ModbusReadReplyParams {
	[ displayName = "Status" ]
	bigendian uint16_t m_status;

	[ displayName = "Event count" ]
	bigendian uint16_t m_eventCount;

	[ displayName = "Message count" ]
	bigendian uint16_t m_messageCount;

	// followed by event log data
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// ModbusFunc.WriteMultipleCoils / WriteMultipleRegisters

struct ModbusWriteMultipleParams {
	[ @ModbusAddressAttr ]
	bigendian uint16_t m_address;

	[ displayName = "Count" ]
	bigendian uint16_t m_count;

	[ displayName = "Size" ]
	uint8_t m_size;

	// followed by write data
}

[
	userAction = "Update size",
	autorun = "Auto-update size"
]
void AutoUpdateSizeAttr;

struct ModbusWriteMultipleCoilsParams: ModbusWriteMultipleParams {
	[ @AutoUpdateSizeAttr ]
	void updateSize() {
		m_size = m_count / 8;
		if (m_count & 7)
			m_size++;
	}
}

struct ModbusWriteMultipleRegistersParams: ModbusWriteMultipleParams {
	[ @AutoUpdateSizeAttr ]
	void updateSize() {
		m_size = m_count * sizeof(uint16_t);
	}
}

struct ModbusWriteMultipleReplyParams {
	[ @ModbusAddressAttr ]
	bigendian uint16_t m_address;

	[ displayName = "Count" ]
	bigendian uint16_t m_count;
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// ModbusFunc.ReadFileRecord/WriteFileRecord

typedef ModbusReadReplyParams ModbusReadWriteFileRecordParams;
typedef ModbusReadReplyPdu ModbusReadWriteFileRecordPdu;

struct ModbusFileRecord {
	uint8_t m_referenceType; // must be 0x06
	bigendian uint16_t m_fileNumber;
	bigendian uint16_t m_recordNumber;
	bigendian uint16_t m_recordCount;
}

struct ModbusReadFileRecordReply {
	uint8_t m_size;
	uint8_t m_referenceType; // must be 0x06
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// ModbusFunc.MaskWriteRegister

struct ModbusMaskWriteParams {
	[ @ModbusAddressAttr ]
	bigendian uint16_t m_address;

	[
		displayName = "AND mask",
		formatSpec = "0x%04X"
	]
	bigendian uint16_t m_andMask;

	[
		displayName = "OR mask",
		formatSpec = "0x%04X"
	]
	bigendian uint16_t m_orMask;
}

typedef ModbusMaskWriteParams ModbusMaskWriteReplyParams;

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// ModbusFunc.ReadWriteMultipleRegisters

struct ModbusReadWriteMultipleRegistersParams {
	[
		displayName = "Read address",
		formatSpec = "0x%04X"
	]
	bigendian uint16_t m_readAddress;

	[ displayName = "Read count" ]
	bigendian uint16_t m_readCount;

	[
		displayName = "Write address",
		formatSpec = "0x%04X"
	]
	bigendian uint16_t m_writeAddress;

	[ displayName = "Write count" ]
	bigendian uint16_t m_writeCount;

	[ displayName = "Write size" ]
	uint8_t m_writeSize;

	// followed by data to be written
}

typedef ModbusReadReplyParams ModbusReadWriteMultipleRegistersReplyParams;

//..............................................................................

// ModbusFunc.ReportServerId

typedef ModbusReadReplyParams ModbusReportServerIdReplyParams;

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// ModbusFunc.ReadFifoQueue

struct ModbusReadFifoQueueParams {
	[ @ModbusAddressAttr ]
	bigendian uint16_t m_address;
}

struct ModbusReadFifoQueueReplyParams {
	[ displayName = "Byte count" ]
	bigendian uint16_t m_byteCount;

	[ displayName = "FIFO count" ]
	bigendian uint16_t m_fifoCount;

	// followed by FIFO data
}

//..............................................................................

// Modbus ADUs

struct ModbusRtuAduHdr {
	[
		displayName = "Device",
		formatSpec = "#%d"
	]
	uint8_t m_deviceAddress;

	// followed by PDU, then CRC16 checksum
}

struct ModbusRtuAduPduHdr:
	ModbusRtuAduHdr,
	ModbusPduHdr {}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

struct ModbusTcpAduHdr {
	[ displayName = "Transaction ID" ]
	bigendian uint16_t m_transactionId;

	[ displayName = "Protocol" ]
	bigendian uint16_t m_protocol;

	[ displayName = "Length" ]
	bigendian uint16_t m_length; // length of data following this field

	[ displayName = "Device" ]
	uint8_t m_deviceAddress;

	// followed by PDU
}

struct ModbusTcpAduPduHdr:
	ModbusTcpAduHdr,
	ModbusPduHdr {}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

enum {
	ModbusFileReferenceType = 6,

	ModbusMaxPduSize        = 253, // historical limit
	ModbusMaxRtuAduSize     = sizeof(ModbusRtuAduHdr) + ModbusMaxPduSize + 2,
	ModbusMaxAsciiAduSize   = 1 + (sizeof(ModbusRtuAduHdr) + ModbusMaxPduSize) * 2 + 4, // :(ADU)(LRC)\r\n
	ModbusMaxTcpAduSize     = sizeof(ModbusTcpAduHdr) + ModbusMaxPduSize,
}

//..............................................................................

// no need to make this one async -- it doesn't read any preceding data

void layoutModbusRegisterValues(
	jnc.DynamicLayout* layout,
	size_t count,
	size_t size
) {
	size_t maxCount = size / sizeof(uint16_t);
	if (count > maxCount)
		count = maxCount;

	dylayout (layout) {
		[
			displayName = "Values",
			backColor = ui.StdColor.PastelYellow,
			digestFunc = getModbusRegisterDigest,
			foldFlag = 2
		]
		dyfield bigendian uint16_t values[count];

		if (size & 1)
			[
				displayName = "Padding",
				backColor = ui.StdColor.PastelOrange,
				binary
			]
			dyfield uint8_t padding;
	}
}

async void layoutModbusPdu(
	jnc.DynamicLayout* layout,
	ModbusRole role
) {
	dylayout (layout) {
		[
			backColor = ui.StdColor.PastelBlue,
			ungroup
		]
		dyfield pdu {
			ModbusFunc func;

			if (role == ModbusRole.Master) { // request
				[ ungroup ]
				dyfield ModbusPduHdr pduHdr;
				func = pduHdr.m_func;
			} else {
				[ ungroup ]
				dyfield ModbusReplyPduHdr pduHdr;
				if (pduHdr.m_exceptionFlag) {
					[ ungroup ]
					dyfield ModbusExceptionParams params;
					return;
				}

				func = (ModbusFunc)pduHdr.m_func;
			}

			switch (func) {
			case io.ModbusFunc.ReadCoils:
			case io.ModbusFunc.ReadDiscreteInputs:
				if (role == ModbusRole.Master) // request
					[ ungroup ]
					dyfield ModbusReadParams params;
				else { // reply
					[ ungroup ]
					dyfield ModbusReadReplyParams params;

					[
						displayName = "Values",
						backColor = ui.StdColor.PastelYellow,
						binary
					]
					dyfield uint8_t data[params.m_size];
				}
				break;

			case io.ModbusFunc.ReadHoldingRegisters:
			case io.ModbusFunc.ReadInputRegisters:
				if (role == ModbusRole.Master) // request
					[ ungroup ]
					dyfield ModbusReadParams params;
				else { // reply
					[ ungroup ]
					dyfield ModbusReadReplyParams params;
					layoutModbusRegisterValues(layout, -1, params.m_size);
				}
				break;

			case io.ModbusFunc.WriteSingleCoil:
			case io.ModbusFunc.WriteSingleRegister:
				[ ungroup ]
				dyfield ModbusWriteSingleParams params; // same for request & reply
				break;

			case io.ModbusFunc.ReadExceptionStatus:
				if (role == ModbusRole.Slave)
					[ ungroup]
					dyfield ModbusReadExceptionStatusReplyParams params;
				break;

			case io.ModbusFunc.Diagnostics:
				std.setError("ModbusFunc.Diagnostics is unsupported");
				throw;

			case io.ModbusFunc.GetCommEventCounter:
				if (role == ModbusRole.Slave)
					[ ungroup]
					dyfield ModbusGetCommEventCounterReplyParams params;

				break;

			case io.ModbusFunc.GetCommEventLog:
				if (role == ModbusRole.Slave) {
					[ ungroup]
					dyfield ModbusGetCommEventLogReplyParams params;

					if (params.m_size > 6)
						[
							displayName = "Values",
							backColor = ui.StdColor.PastelYellow,
							foldFlag = 2
						]
						dyfield uint8_t data[params.m_size - 3 * sizeof(uint16_t)];
				}
				break;

			case io.ModbusFunc.ReportServerId:
				if (role == ModbusRole.Slave) {
					[ ungroup ]
					dyfield ModbusReportServerIdReplyParams params;

					[
						displayName = "Server ID",
						backColor = ui.StdColor.PastelYellow,
						binary
					]
					dyfield uint8_t data[params.m_size];
				}
				break; // no extra params

			case io.ModbusFunc.WriteMultipleCoils:
				if (role == ModbusRole.Master) { // request
					[ ungroup ]
					dyfield ModbusWriteMultipleCoilsParams request;

					[
						displayName = "Values",
						backColor = ui.StdColor.PastelYellow,
						binary
					]
					dyfield uint8_t data[request.m_size];
				} else // reply
					[ ungroup ]
					dyfield ModbusWriteMultipleReplyParams reply;
				break;

			case io.ModbusFunc.WriteMultipleRegisters:
				if (role == ModbusRole.Master) { // request
					[ ungroup ]
					dyfield ModbusWriteMultipleRegistersParams params;
					layoutModbusRegisterValues(layout, params.m_count, params.m_size);
				} else // reply
					[ ungroup ]
					dyfield ModbusWriteMultipleReplyParams params;
				break;

			case io.ModbusFunc.ReadFileRecord:
			case io.ModbusFunc.WriteFileRecord:
				[ ungroup ]
				dyfield ModbusReadWriteFileRecordParams params;

				[
					displayName = "Records",
					backColor = ui.StdColor.PastelYellow,
					binary
				]
				dyfield uint8_t data[params.m_size];
				break;

			case io.ModbusFunc.MaskWriteRegister:
				[ ungroup ]
				dyfield ModbusMaskWriteParams params; // same for request & reply
				break;

			case io.ModbusFunc.ReadWriteMultipleRegisters:
				if (role == ModbusRole.Master) { // request
					[ ungroup ]
					dyfield ModbusReadWriteMultipleRegistersParams params;
					layoutModbusRegisterValues(layout, params.m_writeCount, params.m_writeSize);
				} else { // reply
					[ ungroup ]
					dyfield ModbusReadReplyParams params;
					layoutModbusRegisterValues(layout, -1, params.m_size);
				}
				break;

			case io.ModbusFunc.ReadFifoQueue:
				if (role == ModbusRole.Master) // request
					[ ungroup ]
					dyfield ModbusReadFifoQueueParams params;
				else {
					[ ungroup ]
					dyfield ModbusReadFifoQueueReplyParams params;
					layoutModbusRegisterValues(layout, params.m_fifoCount, params.m_byteCount - sizeof(uint16_t));
				}
				break;

			case io.ModbusFunc.EncapsulatedInterface:
				std.setError("ModbusFunc.EncapsulatedInterface is unsupported");
				throw;

			default:
				std.setError("Unknown Modbus function");
				throw;
			}
		}
	}
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

struct ModbusRtuCrc {
	[
		displayName = "CRC",
		formatFunc  = formatModbusRtuCrc
	]
	uint16_t m_crc; // Modbus RTU CRC is little-endian

	[
		userAction = "Update CRC",
		autorun = "Auto-update CRC"
	]
	void updateCrc() {
		m_crc = calcCrc();
	}

	uint16_t calcCrc() const {
		size_t size = dynamic offsetof(this);
		return crc16_ansi((char const*)this - size, size, 0xffff);
	}
}

string_t getModbusChecksumValidityString(bool isValid) {
	return isValid ? "\e[32mOK\e[m" : "\e[31mERROR\e[m";
}

string_t formatModbusRtuCrc(void const* p) {
	ModbusRtuCrc const* crc = (ModbusRtuCrc const*)p;
	bool isValid = crc.m_crc == crc.calcCrc();

	// \e[m terminates the hyperlink
	return $"0x%04X\e[m [%2]"(crc.m_crc, getModbusChecksumValidityString(isValid));
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

async void layoutModbusRtuAduImpl(
	jnc.DynamicLayout* layout,
	ModbusRole role
) {
	dylayout (layout) {
		[
			backColor = ui.StdColor.PastelPurple,
			ungroup
		]
		dyfield adu {
			[ ungroup ]
			dyfield ModbusRtuAduHdr aduHdr;

			await layoutModbusPdu(layout, role);

			[ ungroup ]
			dyfield ModbusRtuCrc crc;
		}
	}
}

async void layoutModbusRtuAdu(
	jnc.DynamicLayout* layout,
	ModbusRole role
) {
	[
		displayName = "MODBUS RTU",
		displayNameAttr = "\e[1m",
		backColor = ui.StdColor.PastelGray,
		foldFlag = 1,
		root // root groups are for log only (ungrouped in packet templates)
	]
	void AduAttr;

	// attributes are always static and constant -- we can't pass modbus role to the digest func
	// therefore, we just branch and have two declarations (one for master, one for slave)

	dylayout (layout) {
		if (role == ModbusRole.Master)
			[
				@AduAttr,
				digestFunc = getModbusRtuMasterDigest
			]
			dyfield adu {
				await layoutModbusRtuAduImpl(layout, role);
			}
		else
			[
				@AduAttr,
				digestFunc = getModbusRtuSlaveDigest
			]
			dyfield adu {
				await layoutModbusRtuAduImpl(layout, role);
			}
	}
}

string_t getModbusRtuDigest(
	ModbusRtuAduPduHdr const* aduPduHdr,
	ModbusRole role
) {
	static string_t arrows[] = {
		"\u2190", // left arrow
		"\u2192", // right arrow
	}

	static string_t directions[] = {
		"request",
		"reply",
	}

	return $"#%1 %2 %3 \e[90m(%4)\e[m"(
		aduPduHdr.m_deviceAddress,
		arrows[role],
		typeof(ModbusFunc).getValueString(aduPduHdr.m_func),
		directions[role]
	);
}

string_t getModbusRtuMasterDigest(void const* p) {
	return getModbusRtuDigest((ModbusRtuAduPduHdr const*)p, ModbusRole.Master);
}

string_t getModbusRtuSlaveDigest(void const* p) {
	return getModbusRtuDigest((ModbusRtuAduPduHdr const*)p, ModbusRole.Slave);
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

async void layoutModbusTcpAduImpl(
	jnc.DynamicLayout* layout,
	ModbusRole role
) {
	dylayout (layout) {
		[
			backColor = ui.StdColor.PastelPurple,
			ungroup
		]
		dyfield ModbusTcpAduHdr aduHdr;

		await layoutModbusPdu(layout, role);
	}
}

async void layoutModbusTcpAdu(
	jnc.DynamicLayout* layout,
	ModbusRole role
) {
	[
		displayName = "MODBUS TCP",
		displayNameAttr = "\e[1m",
		backColor = ui.StdColor.PastelGray,
		foldFlag = 1,
		root // root groups are for log only (ungrouped in packet templates)
	]
	void AduAttr;

	// attributes are always static and constant -- we can't pass modbus role to the digest func
	// therefore, we just branch and have two declarations (one for master, one for slave)

	dylayout (layout) {
		if (role == ModbusRole.Master)
			[
				@AduAttr,
				digestFunc = getModbusTcpMasterDigest
			]
			dyfield adu {
				await layoutModbusTcpAduImpl(layout, role);
			}
		else
			[
				@AduAttr,
				digestFunc = getModbusTcpSlaveDigest
			]
			dyfield adu {
				await layoutModbusTcpAduImpl(layout, role);
			}
	}
}

string_t getModbusTcpDigest(
	ModbusTcpAduPduHdr const* aduPduHdr,
	ModbusRole role
) {
	return $"%1"(typeof(ModbusFunc).getValueString(aduPduHdr.m_func));
}

string_t getModbusTcpMasterDigest(void const* p) {
	return getModbusTcpDigest((ModbusTcpAduPduHdr const*)p, ModbusRole.Master);
}

string_t getModbusTcpSlaveDigest(void const* p) {
	return getModbusTcpDigest((ModbusTcpAduPduHdr const*)p, ModbusRole.Slave);
}

string_t getModbusRegisterDigest(
	void const* p0,
	size_t size
) {
	size_t count0 = size / sizeof(uint16_t);
	size_t count = count0 < 4 ? count : 4;
	bigendian uint16_t const* p = (bigendian uint16_t const*)p0;
	bigendian uint16_t const* end = p + count;

	std.StringBuilder string;
	string.append('{');
	for (; p < end; p++)
		string.append($" %d,"(*p));

	if (count0 > count)
		string.append(" ... }");
	else {
		string.chop(1);
		string.append(" }");
	}

	return string.detachString();
}

//..............................................................................

// PDU definitions (for the legacy plugin)

struct ModbusExceptionPdu:
	ModbusPduHdr,
	ModbusExceptionParams {}

struct ModbusReadPdu:
	ModbusPduHdr,
	ModbusReadParams {}

struct ModbusReadReplyPdu:
	ModbusPduHdr,
	ModbusReadReplyParams {}

struct ModbusWriteSinglePdu:
	ModbusPduHdr,
	ModbusWriteSingleParams {}

typedef ModbusWriteSinglePdu ModbusWriteSingleReplyPdu;

struct ModbusReadExceptionStatusReplyPdu:
	ModbusPduHdr,
	ModbusReadExceptionStatusReplyParams {}

struct ModbusGetCommEventCounterReplyPdu:
	ModbusPduHdr,
	ModbusGetCommEventCounterReplyParams {}

struct ModbusGetCommEventLogReplyPdu:
	ModbusPduHdr,
	ModbusGetCommEventLogReplyParams {}

struct ModbusWriteMultiplePdu:
	ModbusPduHdr,
	ModbusWriteMultipleParams {}

struct ModbusWriteMultipleReplyPdu:
	ModbusPduHdr,
	ModbusWriteMultipleReplyParams {}

struct ModbusMaskWritePdu:
	ModbusPduHdr,
	ModbusMaskWriteParams {}

typedef ModbusMaskWritePdu ModbusMaskWriteReplyPdu;

struct ModbusReadWriteMultipleRegistersPdu:
	ModbusPduHdr,
	ModbusReadWriteMultipleRegistersParams {}

typedef ModbusReadReplyPdu ModbusReadWriteMultipleRegistersReplyPdu;

struct ModbusReadFifoQueuePdu:
	ModbusPduHdr,
	ModbusReadFifoQueueParams {}

struct ModbusReadFifoQueueReplyPdu:
	ModbusPduHdr,
	ModbusReadFifoQueueReplyParams {}

//..............................................................................

} // namespace io
