//..............................................................................
//
// Modbus RTU/TCP protocol constants and structs
//

import "ui_Color.jnc"
import "crc16.jnc"

namespace io {

//! \addtogroup proto-modbus
//! @{

pragma(Alignment, 1);

//..............................................................................

// Modbus protocol variations

enum ModbusProtocol: uint8_t {
	Rtu,
	Ascii,
	Tcp,
	RtuIp,
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// Modbus node roles

enum ModbusRole: uint8_t {
	Master,
	Slave,
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// Modbus function codes

enum ModbusFunc: uint8_t {
	[ displayName = "Read coils" ]
	ReadCoils                  = 1,

	[ displayName = "Read discrete inputs" ]
	ReadDiscreteInputs         = 2,

	[ displayName = "Read holding registers" ]
	ReadHoldingRegisters       = 3,

	[ displayName = "Read input registers" ]
	ReadInputRegisters         = 4,

	[ displayName = "Write single coil" ]
	WriteSingleCoil            = 5,

	[ displayName = "Write single register" ]
	WriteSingleRegister        = 6,

	[ displayName = "Read exception status" ]
	ReadExceptionStatus	       = 7,

	[ displayName = "Diagnostics" ]
	Diagnostics                = 8,

	[ displayName = "Get comm event counter" ]
	GetCommEventCounter        = 11,

	[ displayName = "Get comm event log" ]
	GetCommEventLog            = 12,

	[ displayName = "Write multiple coils" ]
	WriteMultipleCoils         = 15,

	[ displayName = "Write multiple registers" ]
	WriteMultipleRegisters     = 16,

	[ displayName = "Report server ID" ]
	ReportServerId             = 17,

	[ displayName = "Read file record" ]
	ReadFileRecord             = 20,

	[ displayName = "Write file record" ]
	WriteFileRecord            = 21,

	[ displayName = "Mask write register" ]
	MaskWriteRegister	       = 22,

	[ displayName = "Read/write multiple registers" ]
	ReadWriteMultipleRegisters = 23,

	[ displayName = "Read FIFO queue" ]
	ReadFifoQueue              = 24,

	[ displayName = "Encapsulated interface" ]
	EncapsulatedInterface      = 43,

	[ displayName = "Exception" ]
	ExceptionFlag              = 0x80,
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// exception codes

enum ModbusException: uint8_t {
	[ displayName = "Illegal function" ]
	IllegalFunction         = 1,

	[ displayName = "Illegal data address" ]
	IllegalDataAddress      = 2,

	[ displayName = "Illegal data value" ]
	IllegalDataValue        = 3,

	[ displayName = "Server device failure" ]
	ServerDeviceFailure     = 4,

	[ displayName = "Acknowledge" ]
	Acknowledge             = 5,

	[ displayName = "Server device busy" ]
	ServerDeviceBusy        = 6,

	[ displayName = "Memory parity error" ]
	MemoryParityError       = 8,

	[ displayName = "Gateway path unavailable" ]
	GatewayPathUnavailable  = 10,

	[ displayName = "Gateway device no response" ]
	GatewayDeviceNoResponse = 11,
}

//..............................................................................

// shared attributes for address fields

[
	displayName = "Address",
	formatSpec = "0x%04X"
]
void ModbusAddressAttr;

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// particular function code PDUs

struct ModbusPduHdr {
	[ displayName = "Function" ]
	ModbusFunc m_func;
}

struct ModbusReplyPduHdr {
	[
		displayName = "Function",
		displayType = typeof(ModbusFunc)
	]
	uint8_t m_func: 7;

	[
		displayName = "Exception flag",
		displayType = typeof(bool)
	]
	uint8_t m_exceptionFlag: 1;
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// ModbusFunc.Exception (ModbusPduHdr.m_func has ModbusFunc.ExceptionFlag set)

struct ModbusExceptionParams {
	[ displayName = "Exception code" ]
	ModbusException m_exception;
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// ModbusFunc.ReadCoils / ReadDiscreteInputs / ReadHoldingRegisters / ReadInputRegisters

struct ModbusReadParams {
	[ @ModbusAddressAttr ]
	bigendian uint16_t m_address;

	[ displayName = "Count" ]
	bigendian uint16_t m_count;
}

struct ModbusReadReplyParams {
	[ displayName = "Size" ]
	uint8_t m_size;

	// followed by read data
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

struct ModbusBitBank {
	[ displayName = "[0]" ]
	uchar_t m_coil0: 1;
	[ displayName = "[1]" ]
	uchar_t m_coil1: 1;
	[ displayName = "[2]" ]
	uchar_t m_coil2: 1;
	[ displayName = "[3]" ]
	uchar_t m_coil3: 1;
	[ displayName = "[4]" ]
	uchar_t m_coil4: 1;
	[ displayName = "[5]" ]
	uchar_t m_coil5: 1;
	[ displayName = "[6]" ]
	uchar_t m_coil6: 1;
	[ displayName = "[7]" ]
	uchar_t m_coil7: 1;
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// ModbusFunc.WriteSingleCoil/WriteSingleRegister

struct ModbusWriteSingleParams {
	[ @ModbusAddressAttr ]
	bigendian uint16_t m_address;

	[ displayName = "Value" ]
	bigendian uint16_t m_value;
}

typedef ModbusWriteSingleParams ModbusWriteSingleReplyParams;

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// ModbusFunc.ReadExceptionStatus

struct ModbusReadExceptionStatusReplyParams {
	[ displayName = "Status" ]
	uint8_t m_status;
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// ModbusFunc.GetCommEventCounter

struct ModbusGetCommEventCounterReplyParams {
	[ displayName = "Status" ]
	bigendian uint16_t m_status;

	[ displayName = "Event count" ]
	bigendian uint16_t m_eventCount;
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// ModbusFunc.GetCommEventLog

struct ModbusGetCommEventLogReplyParams: ModbusReadReplyParams {
	[ displayName = "Status" ]
	bigendian uint16_t m_status;

	[ displayName = "Event count" ]
	bigendian uint16_t m_eventCount;

	[ displayName = "Message count" ]
	bigendian uint16_t m_messageCount;

	// followed by event log data
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// ModbusFunc.WriteMultipleCoils / WriteMultipleRegisters

struct ModbusWriteMultipleParams {
	[ @ModbusAddressAttr ]
	bigendian uint16_t m_address;

	[ displayName = "Count" ]
	bigendian uint16_t m_count;

	[ displayName = "Size" ]
	uint8_t m_size;

	// followed by write data
}

[
	userAction = "Update size",
	autorun = "Auto-update size"
]
void AutoUpdateSizeAttr;

struct ModbusWriteMultipleCoilsParams: ModbusWriteMultipleParams {
	[ @AutoUpdateSizeAttr ]
	void updateSize() {
		m_size = m_count / 8;
		if (m_count & 7)
			m_size++;
	}
}

struct ModbusWriteMultipleRegistersParams: ModbusWriteMultipleParams {
	[ @AutoUpdateSizeAttr ]
	void updateSize() {
		m_size = m_count * sizeof(uint16_t);
	}
}

struct ModbusWriteMultipleReplyParams {
	[ @ModbusAddressAttr ]
	bigendian uint16_t m_address;

	[ displayName = "Count" ]
	bigendian uint16_t m_count;
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// ModbusFunc.ReadFileRecord/WriteFileRecord

typedef ModbusReadReplyParams ModbusReadWriteFileRecordParams;
typedef ModbusReadReplyPdu ModbusReadWriteFileRecordPdu;

struct ModbusFileRecord {
	uint8_t m_referenceType; // must be 0x06
	bigendian uint16_t m_fileNumber;
	bigendian uint16_t m_recordNumber;
	bigendian uint16_t m_recordCount;
}

struct ModbusReadFileRecordReply {
	uint8_t m_size;
	uint8_t m_referenceType; // must be 0x06
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// ModbusFunc.MaskWriteRegister

struct ModbusMaskWriteParams {
	[ @ModbusAddressAttr ]
	bigendian uint16_t m_address;

	[
		displayName = "AND mask",
		formatSpec = "0x%04X"
	]
	bigendian uint16_t m_andMask;

	[
		displayName = "OR mask",
		formatSpec = "0x%04X"
	]
	bigendian uint16_t m_orMask;
}

typedef ModbusMaskWriteParams ModbusMaskWriteReplyParams;

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// ModbusFunc.ReadWriteMultipleRegisters

struct ModbusReadWriteMultipleRegistersParams {
	[
		displayName = "Read address",
		formatSpec = "0x%04X"
	]
	bigendian uint16_t m_readAddress;

	[ displayName = "Read count" ]
	bigendian uint16_t m_readCount;

	[
		displayName = "Write address",
		formatSpec = "0x%04X"
	]
	bigendian uint16_t m_writeAddress;

	[ displayName = "Write count" ]
	bigendian uint16_t m_writeCount;

	[ displayName = "Write size" ]
	uint8_t m_writeSize;

	// followed by data to be written
}

typedef ModbusReadReplyParams ModbusReadWriteMultipleRegistersReplyParams;

//..............................................................................

// ModbusFunc.ReportServerId

typedef ModbusReadReplyParams ModbusReportServerIdReplyParams;

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// ModbusFunc.ReadFifoQueue

struct ModbusReadFifoQueueParams {
	[ @ModbusAddressAttr ]
	bigendian uint16_t m_address;
}

struct ModbusReadFifoQueueReplyParams {
	[ displayName = "Byte count" ]
	bigendian uint16_t m_byteCount;

	[ displayName = "FIFO count" ]
	bigendian uint16_t m_fifoCount;

	// followed by FIFO data
}

//..............................................................................

// Modbus ADUs

struct ModbusRtuAduHdr {
	[
		displayName = "Device",
		formatSpec = "#%d"
	]
	uint8_t m_deviceAddress;

	// followed by PDU, then CRC16 checksum
}

struct ModbusRtuAduPduHdr:
	ModbusRtuAduHdr,
	ModbusPduHdr {}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

struct ModbusTcpAduHdr {
	[ displayName = "Transaction ID" ]
	bigendian uint16_t m_transactionId;

	[ displayName = "Protocol" ]
	bigendian uint16_t m_protocol;

	[ displayName = "Length" ]
	bigendian uint16_t m_length; // length of data following this field

	[ displayName = "Device" ]
	uint8_t m_deviceAddress;

	// followed by PDU
}

struct ModbusTcpAduPduHdr:
	ModbusTcpAduHdr,
	ModbusPduHdr {}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

enum {
	ModbusFileReferenceType = 6,

	ModbusMaxPduSize        = 253, // historical limit
	ModbusMaxRtuAduSize     = sizeof(ModbusRtuAduHdr) + ModbusMaxPduSize + 2,
	ModbusMaxAsciiAduSize   = 1 + (sizeof(ModbusRtuAduHdr) + ModbusMaxPduSize) * 2 + 4, // :(ADU)(LRC)\r\n
	ModbusMaxTcpAduSize     = sizeof(ModbusTcpAduHdr) + ModbusMaxPduSize,
}

//..............................................................................

// no need to make this one async -- it doesn't read any preceding data

void layoutModbusRegisters(
	jnc.DynamicLayout* layout,
	size_t count,
	size_t size
) {
	size_t maxCount = size / sizeof(uint16_t);
	if (count > maxCount)
		count = maxCount;

	dylayout (layout) {
		[
			displayName = "Values",
			backColor = ui.StdColor.PastelYellow,
			digestFunc = getModbusRegisterDigest,
			foldFlag = 2
		]
		dyfield bigendian uint16_t values[count];

		if (size & 1)
			[
				displayName = "Padding",
				backColor = ui.StdColor.PastelOrange,
				binary
			]
			dyfield uint8_t padding;
	}
}

async void layoutModbusPdu(
	jnc.DynamicLayout* layout,
	ModbusRole role
) {
	[
		displayName = "Values",
		backColor = ui.StdColor.PastelYellow,
		digestFunc = getModbusBitDigest,
		foldFlag = 2
	]
	void ModbusBitBankAttr;

	dylayout (layout) {
		[
			backColor = ui.StdColor.PastelBlue,
			ungroup
		]
		dyfield pdu {
			ModbusFunc func;

			if (role == ModbusRole.Master) { // request
				[ ungroup ]
				dyfield ModbusPduHdr pduHdr;
				func = pduHdr.m_func;
			} else {
				[ ungroup ]
				dyfield ModbusReplyPduHdr pduHdr;
				if (pduHdr.m_exceptionFlag) {
					[ ungroup ]
					dyfield ModbusExceptionParams params;
					return;
				}

				func = (ModbusFunc)pduHdr.m_func;
			}

			switch (func) {
			case ModbusFunc.ReadCoils:
			case ModbusFunc.ReadDiscreteInputs:
			case ModbusFunc.ReadHoldingRegisters:
			case ModbusFunc.ReadInputRegisters:
				if (role == ModbusRole.Master) // request
					[ ungroup ]
					dyfield ModbusReadParams params;
				else { // reply
					[ ungroup ]
					dyfield ModbusReadReplyParams params;

					if (func <= ModbusFunc.ReadDiscreteInputs)
						[ @ModbusBitBankAttr ]
						dyfield ModbusBitBank values[params.m_size];
					else
						layoutModbusRegisters(layout, -1, params.m_size);
				}
				break;


			case ModbusFunc.WriteSingleCoil:
			case ModbusFunc.WriteSingleRegister:
				[ ungroup ]
				dyfield ModbusWriteSingleParams params; // same for request & reply
				break;

			case ModbusFunc.ReadExceptionStatus:
				if (role == ModbusRole.Slave)
					[ ungroup]
					dyfield ModbusReadExceptionStatusReplyParams params;
				break;

			case ModbusFunc.Diagnostics:
				std.setError("ModbusFunc.Diagnostics is unsupported");
				throw;

			case ModbusFunc.GetCommEventCounter:
				if (role == ModbusRole.Slave)
					[ ungroup]
					dyfield ModbusGetCommEventCounterReplyParams params;

				break;

			case ModbusFunc.GetCommEventLog:
				if (role == ModbusRole.Slave) {
					[ ungroup]
					dyfield ModbusGetCommEventLogReplyParams params;

					if (params.m_size > 6)
						[
							displayName = "Values",
							backColor = ui.StdColor.PastelYellow,
							foldFlag = 2
						]
						dyfield uint8_t data[params.m_size - 3 * sizeof(uint16_t)];
				}
				break;

			case ModbusFunc.ReportServerId:
				if (role == ModbusRole.Slave) {
					[ ungroup ]
					dyfield ModbusReportServerIdReplyParams params;

					[
						displayName = "Server ID",
						backColor = ui.StdColor.PastelYellow,
						binary
					]
					dyfield uint8_t data[params.m_size];
				}
				break; // no extra params

			case ModbusFunc.WriteMultipleCoils:
				if (role == ModbusRole.Master) { // request
					[ ungroup ]
					dyfield ModbusWriteMultipleCoilsParams params;

					[ @ModbusBitBankAttr ]
					dyfield ModbusBitBank values[params.m_size];
				} else // reply
					[ ungroup ]
					dyfield ModbusWriteMultipleReplyParams reply;
				break;

			case ModbusFunc.WriteMultipleRegisters:
				if (role == ModbusRole.Master) { // request
					[ ungroup ]
					dyfield ModbusWriteMultipleRegistersParams params;
					layoutModbusRegisters(layout, params.m_count, params.m_size);
				} else // reply
					[ ungroup ]
					dyfield ModbusWriteMultipleReplyParams params;
				break;

			case ModbusFunc.ReadFileRecord:
			case ModbusFunc.WriteFileRecord:
				[ ungroup ]
				dyfield ModbusReadWriteFileRecordParams params;

				[
					displayName = "Records",
					backColor = ui.StdColor.PastelYellow,
					binary
				]
				dyfield uint8_t data[params.m_size];
				break;

			case ModbusFunc.MaskWriteRegister:
				[ ungroup ]
				dyfield ModbusMaskWriteParams params; // same for request & reply
				break;

			case ModbusFunc.ReadWriteMultipleRegisters:
				if (role == ModbusRole.Master) { // request
					[ ungroup ]
					dyfield ModbusReadWriteMultipleRegistersParams params;
					layoutModbusRegisters(layout, params.m_writeCount, params.m_writeSize);
				} else { // reply
					[ ungroup ]
					dyfield ModbusReadReplyParams params;
					layoutModbusRegisters(layout, -1, params.m_size);
				}
				break;

			case ModbusFunc.ReadFifoQueue:
				if (role == ModbusRole.Master) // request
					[ ungroup ]
					dyfield ModbusReadFifoQueueParams params;
				else {
					[ ungroup ]
					dyfield ModbusReadFifoQueueReplyParams params;
					layoutModbusRegisters(layout, params.m_fifoCount, params.m_byteCount - sizeof(uint16_t));
				}
				break;

			case ModbusFunc.EncapsulatedInterface:
				std.setError("ModbusFunc.EncapsulatedInterface is unsupported");
				throw;

			default:
				std.setError("Unknown Modbus function");
				throw;
			}
		}
	}
}

void appendModbusPduDigest(
	std.StringBuilder* digest,
	void const* p,
	size_t size,
	ModbusRole role
) {
	jnc.DynamicLayout layout(p, size);
	dylayout (layout) {
		static string_t directions[] = {
			"request",
			"reply",
		}

		dyfield ModbusPduHdr pduHdr;
		if (!(pduHdr.m_func & ModbusFunc.ExceptionFlag))
			digest.append($"\e[34m%1\e[m (%2)"(
				typeof(ModbusFunc).getValueString(pduHdr.m_func),
				directions[role]
			));
		else {
			dyfield ModbusExceptionParams params;
			digest.append($"\e[34m%1\e[m (EXCEPTION: \e[31m%2\e[m)"(
				typeof(ModbusFunc).getValueString(pduHdr.m_func & ~ModbusFunc.ExceptionFlag),
				typeof(ModbusException).getValueString(params.m_exception)
			));
		}

		switch (pduHdr.m_func) {
		case ModbusFunc.ReadCoils:
		case ModbusFunc.ReadDiscreteInputs:
		case ModbusFunc.ReadHoldingRegisters:
		case ModbusFunc.ReadInputRegisters:
			if (role == ModbusRole.Master) {
				dyfield ModbusReadParams params;
				digest.append($" Addr: \e[34m0x$(params.m_address; 04x)\e[m");
				if (params.m_count > 1)
					digest.append($" N: \e[34m$(params.m_count)\e[m");
			} else {
				dyfield ModbusReadReplyParams params;
				digest.append(' ');

				if (pduHdr.m_func <= ModbusFunc.ReadDiscreteInputs)
					digest.append(getModbusBitDigest(&params + 1, params.m_size));
				else
					digest.append(getModbusRegisterDigest(&params + 1, params.m_size));
			}
			break;

		case ModbusFunc.WriteSingleCoil:
		case ModbusFunc.WriteSingleRegister:
			dyfield ModbusWriteSingleParams params;
			digest.append($" Addr: \e[34m0x$(params.m_address; 04x)\e[m Val: \e[34m$(params.m_value)\e[m");
			break;

		case ModbusFunc.WriteMultipleCoils:
		case ModbusFunc.WriteMultipleRegisters:
			if (role == ModbusRole.Master) {
				dyfield ModbusWriteMultipleParams params;
				digest.append($" Addr: \e[34m0x$(params.m_address; 04x)\e[m ");

				if (pduHdr.m_func == ModbusFunc.WriteMultipleCoils)
					digest.append(getModbusBitDigest(&params + 1, params.m_size));
				else
					digest.append(getModbusRegisterDigest(&params + 1, params.m_size));
			} else {
				dyfield ModbusWriteMultipleReplyParams params;
				digest.append($" Addr: \e[34m0x$(params.m_address; 04x) N: \e[34m$(params.m_count)\e[m");
			}
			break;

		case ModbusFunc.MaskWriteRegister:
			dyfield ModbusMaskWriteParams params;
			digest.append(
				$" Addr: \e[34m0x%(1; 04x)\e[m Masks: \e[34m0x%(2; 04x)\e[m/\e[34m0x%(3; 04x)\e[m"(
				params.m_address,
				params.m_andMask,
				params.m_orMask
			));
			break;

		case ModbusFunc.ReadWriteMultipleRegisters:
			if (role == ModbusRole.Master) {
				dyfield ModbusReadWriteMultipleRegistersParams params;
				digest.append($" Addr: \e[34m0x$(params.m_readAddress; 04x)/0x$(params.m_writeAddress; 04x)\e[m ");
				digest.append(getModbusRegisterDigest(&params + 1, params.m_writeSize));
			} else {
				dyfield ModbusReadReplyParams params;
				digest.append(' ');
				digest.append(getModbusRegisterDigest(&params + 1, params.m_size));
			}
			break;

		case ModbusFunc.ReadExceptionStatus:
		case ModbusFunc.Diagnostics:
		case ModbusFunc.GetCommEventCounter:
		case ModbusFunc.GetCommEventLog:
		case ModbusFunc.ReportServerId:
		case ModbusFunc.ReadFileRecord:
		case ModbusFunc.WriteFileRecord:
		case ModbusFunc.ReadFifoQueue:
		case ModbusFunc.EncapsulatedInterface:
			break; // not yet
		}
	}
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

uint16_t crc16_modbus(
	void const* p,
	size_t size
) {
	return crc16_ansi(p, size, 0xffff);
}

struct ModbusRtuCrc {
	[
		displayName = "CRC",
		formatFunc  = formatModbusRtuCrc
	]
	uint16_t m_crc; // Modbus RTU CRC is little-endian

	[
		userAction = "Update CRC",
		autorun = "Auto-update CRC"
	]
	void updateCrc() {
		m_crc = calcCrc();
	}

	uint16_t calcCrc() const {
		size_t size = dynamic offsetof(this);
		return crc16_modbus((char const*)this - size, size);
	}
}

string_t getModbusChecksumValidityString(bool isValid) {
	return isValid ? "\e[32mOK\e[m" : "\e[31mERROR\e[m";
}

string_t formatModbusRtuCrc(void const* p) {
	ModbusRtuCrc const* crc = (ModbusRtuCrc const*)p;
	bool isValid = crc.m_crc == crc.calcCrc();

	// \e[m terminates the hyperlink
	return $"0x%04X\e[m [%2]"(crc.m_crc, getModbusChecksumValidityString(isValid));
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

async void layoutModbusRtuAduImpl(
	jnc.DynamicLayout* layout,
	ModbusRole role
) {
	dylayout (layout) {
		[
			backColor = ui.StdColor.PastelPurple,
			ungroup
		]
		dyfield adu {
			[ ungroup ]
			dyfield ModbusRtuAduHdr aduHdr;

			await layoutModbusPdu(layout, role);

			[ ungroup ]
			dyfield ModbusRtuCrc crc;
		}
	}
}

async void layoutModbusRtuAdu(
	jnc.DynamicLayout* layout,
	ModbusRole role
) {
	[
		displayName = "MODBUS RTU",
		displayNameAttr = "\e[1m",
		backColor = ui.StdColor.PastelGray,
		foldFlag = 1,
		root // root groups are for log only (ungrouped in packet templates)
	]
	void AduAttr;

	// attributes are always static and constant -- we can't pass modbus role to the digest func
	// therefore, we just branch and have two declarations (one for master, one for slave)

	dylayout (layout) {
		if (role == ModbusRole.Master)
			[
				@AduAttr,
				digestFunc = getModbusRtuMasterDigest
			]
			dyfield adu {
				await layoutModbusRtuAduImpl(layout, role);
			}
		else
			[
				@AduAttr,
				digestFunc = getModbusRtuSlaveDigest
			]
			dyfield adu {
				await layoutModbusRtuAduImpl(layout, role);
			}
	}
}

string_t getModbusRtuDigest(
	void const* p,
	size_t size,
	ModbusRole role
) {
	static string_t arrows[] = {
		"\u2190", // left arrow
		"\u2192", // right arrow
	}

	ModbusRtuAduHdr const* aduHdr = (ModbusRtuAduHdr const*)p;
	std.StringBuilder digest;
	digest = $"Dev: %1 %2 "(aduHdr.m_deviceAddress, arrows[role]);

	appendModbusPduDigest(
		digest,
		p + sizeof(ModbusRtuAduHdr),
		size - sizeof(ModbusRtuAduHdr) - sizeof(uint16_t),
		role
	);

	size -= sizeof(uint16_t);
	uint16_t const* crc = (uint16_t const*)(p + size);
	if (*crc != crc16_modbus(p, size))
		digest.append(" [\e[31mCRC ERROR\e[m]");

	return digest.detachString();
}

string_t getModbusRtuMasterDigest(void const* p) {
	return getModbusRtuDigest((ModbusRtuAduPduHdr const*)p, dynamic sizeof(p), ModbusRole.Master);
}

string_t getModbusRtuSlaveDigest(void const* p) {
	return getModbusRtuDigest((ModbusRtuAduPduHdr const*)p, dynamic sizeof(p), ModbusRole.Slave);
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

async void layoutModbusTcpAduImpl(
	jnc.DynamicLayout* layout,
	ModbusRole role
) {
	dylayout (layout) {
		[
			backColor = ui.StdColor.PastelPurple,
			ungroup
		]
		dyfield ModbusTcpAduHdr aduHdr;

		await layoutModbusPdu(layout, role);
	}
}

async void layoutModbusTcpAdu(
	jnc.DynamicLayout* layout,
	ModbusRole role
) {
	[
		displayName = "MODBUS TCP",
		displayNameAttr = "\e[1m",
		backColor = ui.StdColor.PastelGray,
		foldFlag = 1,
		root // root groups are for log only (ungrouped in packet templates)
	]
	void AduAttr;

	// attributes are always static and constant -- we can't pass modbus role to the digest func
	// therefore, we just branch and have two declarations (one for master, one for slave)

	dylayout (layout) {
		if (role == ModbusRole.Master)
			[
				@AduAttr,
				digestFunc = getModbusTcpMasterDigest
			]
			dyfield adu {
				await layoutModbusTcpAduImpl(layout, role);
			}
		else
			[
				@AduAttr,
				digestFunc = getModbusTcpSlaveDigest
			]
			dyfield adu {
				await layoutModbusTcpAduImpl(layout, role);
			}
	}
}

string_t getModbusTcpDigest(
	void const* p,
	size_t size,
	ModbusRole role
) {
	static string_t arrows[] = {
		"\u2190", // left arrow
		"\u2192", // right arrow
	}

	ModbusTcpAduHdr const* aduHdr = (ModbusTcpAduHdr const*)p;
	std.StringBuilder digest;
	digest = $"TID: %04x Dev: %2 %3 "(aduHdr.m_transactionId, aduHdr.m_deviceAddress, arrows[role]);

	appendModbusPduDigest(
		digest,
		p + sizeof(ModbusRtuAduHdr),
		size - sizeof(ModbusRtuAduHdr) - sizeof(uint16_t),
		role
	);

	return digest.detachString();
}

string_t getModbusTcpMasterDigest(void const* p) {
	return getModbusTcpDigest(p, dynamic sizeof(p), ModbusRole.Master);
}

string_t getModbusTcpSlaveDigest(void const* p) {
	return getModbusTcpDigest(p, dynamic sizeof(p), ModbusRole.Slave);
}

enum {
	ModbusDigestValueCount = 3
}

string_t getModbusRegisterDigest(
	void const* p0,
	size_t size
) {
	size_t count0 = size / sizeof(uint16_t);
	size_t count = count0 < ModbusDigestValueCount ? count0 : ModbusDigestValueCount;
	bigendian uint16_t const* p = (bigendian uint16_t const*)p0;
	bigendian uint16_t const* end = p + count;

	std.StringBuilder digest;
	digest.append('{');
	for (; p < end; p++)
		digest.append($" %d,"(*p));

	if (count0 > count)
		digest.append(" ... }");
	else {
		digest.chop(1);
		digest.append(" }");
	}

	return digest.detachString();
}

string_t getModbusBitDigest(
	void const* p,
	size_t size
) {
	if (!size)
		return "{ }";

	size_t count0 = size * 8;

	std.StringBuilder digest;
	digest.append('{');

	uchar_t x = *(uchar_t const*)p;
	uchar_t mask = 1;
	for (size_t i = 0; i < ModbusDigestValueCount; i++, x >>= 1)
		digest.append($" %d,"(x & 1));

	digest.append(" ... }");
	return digest.detachString();
}

//..............................................................................

// PDU definitions (for the legacy plugin)

struct ModbusExceptionPdu:
	ModbusPduHdr,
	ModbusExceptionParams {}

struct ModbusReadPdu:
	ModbusPduHdr,
	ModbusReadParams {}

struct ModbusReadReplyPdu:
	ModbusPduHdr,
	ModbusReadReplyParams {}

struct ModbusWriteSinglePdu:
	ModbusPduHdr,
	ModbusWriteSingleParams {}

typedef ModbusWriteSinglePdu ModbusWriteSingleReplyPdu;

struct ModbusReadExceptionStatusReplyPdu:
	ModbusPduHdr,
	ModbusReadExceptionStatusReplyParams {}

struct ModbusGetCommEventCounterReplyPdu:
	ModbusPduHdr,
	ModbusGetCommEventCounterReplyParams {}

struct ModbusGetCommEventLogReplyPdu:
	ModbusPduHdr,
	ModbusGetCommEventLogReplyParams {}

struct ModbusWriteMultiplePdu:
	ModbusPduHdr,
	ModbusWriteMultipleParams {}

struct ModbusWriteMultipleReplyPdu:
	ModbusPduHdr,
	ModbusWriteMultipleReplyParams {}

struct ModbusMaskWritePdu:
	ModbusPduHdr,
	ModbusMaskWriteParams {}

typedef ModbusMaskWritePdu ModbusMaskWriteReplyPdu;

struct ModbusReadWriteMultipleRegistersPdu:
	ModbusPduHdr,
	ModbusReadWriteMultipleRegistersParams {}

typedef ModbusReadReplyPdu ModbusReadWriteMultipleRegistersReplyPdu;

struct ModbusReadFifoQueuePdu:
	ModbusPduHdr,
	ModbusReadFifoQueueParams {}

struct ModbusReadFifoQueueReplyPdu:
	ModbusPduHdr,
	ModbusReadFifoQueueReplyParams {}

//..............................................................................

} // namespace io
