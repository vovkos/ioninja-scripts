//..............................................................................
//
// Serial Tap Pro protocol decoder
//

import "std_Buffer.jnc"
import "io_abr.jncx"

//..............................................................................

class SerialTapProDecoder {
protected:
	enum {
		DeviceTimeSyncThreshold = 500000,  // 500 ms (in mcsec)
		AbrBaudRateCap          = 1000000, // should't go any higher with 1 mcs precision
		AbrUpdateInterval       = 5000000, // 500 ms (in 100-nsec)
	}

protected:
	log.Writer* m_logWriter;
	log.TxRxStats* m_txRxStats;
	SerialTapProInfoSet* m_infoSet;
	uint64_t m_timestamp;
	SerialTapProRawUsbBulkParams m_recordParams;

	io.AutoBaudRate m_abr_0;
	io.AutoBaudRate m_abr_1;
	uint64_t m_abrTime;
	uint64_t m_abrUpdateTime;

public:
	SerialTapProIface bindable readonly m_serialIface;
	bool readonly m_isFlipped;

public:
	construct(
		log.Writer* logWriter,
		log.TxRxStats* txRxStats,
		SerialTapProInfoSet* infoSet
	);

	void reset(
		SerialTapProIface iface,
		SerialTapProLines lines
	);

	void configureAbr(
		size_t baudRateGridCount,
		double edgeErrorTolerance,
		double harmonicTolerance,
		uint64_t horizon
	);

	void flip(bool isFlipped);

	void decode(
		char const* p,
		size_t size
	);
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

SerialTapProDecoder.construct(
	log.Writer* logWriter,
	log.TxRxStats* txRxStats,
	SerialTapProInfoSet* infoSet
) {
	m_logWriter = logWriter;
	m_txRxStats = txRxStats;
	m_infoSet = infoSet;

	m_abr_0.create();
	m_abr_1.create();
}

void SerialTapProDecoder.reset(
	SerialTapProIface iface,
	SerialTapProLines lines
) {
	m_timestamp = sys.getTimestamp();
	m_serialIface = iface;
	m_recordParams.m_status = iface;
	m_recordParams.m_lines = lines;

	m_abr_0.reset((lines & SerialTapProLines.Data_0) != 0);
	m_abr_1.reset((lines & SerialTapProLines.Data_1) != 0);
	m_abrTime = m_timestamp;
	m_abrUpdateTime = m_timestamp;

	m_infoSet.updateAbr(0, m_abr_0);
	m_infoSet.updateAbr(1, m_abr_1);
}

void SerialTapProDecoder.configureAbr(
	size_t baudRateGridCount,
	double edgeErrorTolerance,
	double harmonicTolerance,
	uint64_t horizon
) {
	if (baudRateGridCount != m_abr_0.m_baudGridCellCount) {
		m_abr_0.create(AbrBaudRateCap, baudRateGridCount);
		m_abr_1.create(AbrBaudRateCap, baudRateGridCount);
	}

	m_abr_0.m_edgeErrorTolerance = edgeErrorTolerance;
	m_abr_1.m_edgeErrorTolerance = edgeErrorTolerance;
	m_abr_0.m_harmonicTolerance = harmonicTolerance;
	m_abr_1.m_harmonicTolerance = harmonicTolerance;
	m_abr_0.m_horizon = horizon;
	m_abr_1.m_horizon = horizon;
}

void SerialTapProDecoder.flip(bool isFlipped) {
	if (m_isFlipped == isFlipped)
		return;

	m_isFlipped = isFlipped;

	uint8_t status, status0;
	SerialTapProLines lines, lines0;

	if (isFlipped) {
		status = flipSerialTapProOverflows(m_recordParams.m_status);
		status0 = m_recordParams.m_status;
		lines = flipSerialTapProLines(m_recordParams.m_lines);
		lines0 = m_recordParams.m_lines;
	} else {
		status = m_recordParams.m_status;
		status0 = flipSerialTapProOverflows(m_recordParams.m_status);
		lines = m_recordParams.m_lines;
		lines0 = flipSerialTapProLines(m_recordParams.m_lines);
	}

	SerialTapProOverflows overflowMask = (status ^ status0) & SerialTapProOverflows.Mask;
	if (overflowMask)
		m_infoSet.setOverflows((SerialTapProOverflows)status);

	SerialTapProLines lineMask = lines ^ lines0;
	if (lineMask)
		m_infoSet.updateLines(lines, lineMask);
}

void SerialTapProDecoder.decode(
	char const* p0,
	size_t size
) {
	char thin const* p = p0;
	char thin const* end = p + size;
	char const* next = p0 + SerialTapProUsb.BulkSize;
	uint64_t deviceTime = 0;
	uint8_t status = m_recordParams.m_status;
	uint8_t status0 = m_recordParams.m_status;
	SerialTapProLines lines = m_recordParams.m_lines;
	SerialTapProLines lines0 = m_recordParams.m_lines;
	size_t dataSize_0 = 0;
	size_t dataSize_1 = 0;
	bool isTimestampUpdated = false; // update once per USB read (on the first notification)
	bool isAbrUpdated_0 = false;
	bool isAbrUpdated_1 = false;

	while (p < end) {
		SerialTapProNotificationCode code;
		if (p >= next || !(code = (SerialTapProNotificationCode)*p)) { // skip to the end of bulk
			size_t offset = p - p0;
			if (offset) {
				m_logWriter.write(m_timestamp, SerialTapProLogRecordCode.RawUsbBulkData, &m_recordParams, sizeof(m_recordParams), p0, offset);
				m_recordParams.m_status = status;
				m_recordParams.m_lines = lines;
			}

			p = p0 = next;
			next += SerialTapProUsb.BulkSize;
			m_timestamp += deviceTime  * 10; // device time is in mcs
			deviceTime = 0;
			continue;
		}

		DecodeUlebResult uleb = decodeUleb(p + 1, end);
		p = uleb.m_p;
		deviceTime += uleb.m_value;

		if (!isTimestampUpdated) {
			if (deviceTime >= DeviceTimeSyncThreshold)
				m_timestamp = sys.getTimestamp() - deviceTime * 10;

			isTimestampUpdated = true;
		}

		switch (code) {
		case SerialTapProNotificationCode.Data_0:
			dataSize_0++;
			p += 2;
			break;

		case SerialTapProNotificationCode.Data_1:
			dataSize_1++;
			p += 2;
			break;

		case SerialTapProNotificationCode.StatusLineChange:
			lines = (SerialTapProLines)*p++;
			break;

		case SerialTapProNotificationCode.Status:
			status = *p++;
			break;

		case SerialTapProNotificationCode.BreakOn_0:
			lines |= SerialTapProLines.Break_0;
			break;

		case SerialTapProNotificationCode.BreakOn_1:
			lines |= SerialTapProLines.Break_1;
			break;

		case SerialTapProNotificationCode.BreakOff_0:
			lines &= ~SerialTapProLines.Break_0;
			break;

		case SerialTapProNotificationCode.BreakOff_1:
			lines &= ~SerialTapProLines.Break_1;
			break;

		case SerialTapProNotificationCode.EdgeUp_0:
		case SerialTapProNotificationCode.EdgeDown_0:
		case SerialTapProNotificationCode.EdgeUp_1:
		case SerialTapProNotificationCode.EdgeDown_1:
			uint64_t abrTime = m_timestamp + deviceTime * 10;
			uint64_t dtime = abrTime - m_abrTime;
			m_abrTime = abrTime;

			if (code >= SerialTapProNotificationCode.EdgeUp_1) {
				m_abr_0.addEdge(dtime);
				isAbrUpdated_0 = true;
			} else {
				m_abr_1.addEdge(dtime);
				isAbrUpdated_1 = true;
			}

			break;
		}
	}

	// write the remainder (only possible if a bulk is completely filled)

	if (p0 < end) {
		m_logWriter.write(m_timestamp, SerialTapProLogRecordCode.RawUsbBulkData, &m_recordParams, sizeof(m_recordParams), p0, end - p0);
		m_recordParams.m_status = status;
		m_recordParams.m_lines = lines;
		m_timestamp += deviceTime  * 10; // device time is in mcs
	}

	if (m_isFlipped) {
		status = flipSerialTapProOverflows(status);
		status0 = flipSerialTapProOverflows(status0);
		lines = flipSerialTapProLines(lines);
		lines0 = flipSerialTapProLines(lines0);
		size_t t = dataSize_0;
		dataSize_0 = dataSize_1;
		dataSize_1 = t;
	}

	// update stats & the info set

	m_txRxStats.addTx(dataSize_0);
	m_txRxStats.addRx(dataSize_1);

	if ((status ^ status0) & SerialTapProIface.Mask) {
		m_serialIface = (SerialTapProIface)(status & SerialTapProIface.Mask);
		m_infoSet.setIface(m_serialIface);
	}

	if ((status ^ status0) & SerialTapProOverflows.Mask)
		m_infoSet.setOverflows((SerialTapProOverflows)status);

	SerialTapProLines lineMask = lines ^ lines0;
	if (lineMask)
		m_infoSet.updateLines(lines, lineMask);

	if (isAbrUpdated_0) {
		m_infoSet.updateAbr(0, m_abr_0);
		m_abrUpdateTime = m_timestamp;
	}

	if (isAbrUpdated_1) {
		m_infoSet.updateAbr(1, m_abr_1);
		m_abrUpdateTime = m_timestamp;
	}
}

//..............................................................................
