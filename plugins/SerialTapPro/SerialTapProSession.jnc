//..............................................................................
//
// Serial Tap Pro session
//

import "doc_Session.jnc"
import "io_usb.jncx"
import "io_UsbDevice.jnc"
import "io_UsbEnumerator.jnc"
import "iox_FpgaUploader.jnc"
import "ui_SerialUi.jnc"
import "ui_BufferPropertySet.jnc"
import "ui_StdSessionInfoSet.jnc"
import "log_ThroughputCalc.jnc"
import "log_ChecksumCalc.jnc"
import "std_Buffer.jnc"

//..............................................................................

class SerialTapProSession: doc.Session {
protected:
	enum Protocol {
		Spi,
		I2c,
	}

	enum Defaults {
		ReadParallelism = 4,
		ReadBlockSize   = 64 * 1024,
		ReadBufferSize  = 1 * 1024 * 1024,
	}

	enum {
		CypressBufferSize         = 4 * 1024, // 4K (2K built-in in Cypress + 512 FPGA FIFO)
		CypressClearBufferTimeout = 200,      // 0.2 sec
		FpgaUploadBaseIndex       = 0x1000,
		FpgaFreq                  = 48000000,
	}

	enum State {
		Closed,
		Uploading,
		Capturing,
	}

	string_t m_statusTextTable[] = {
		"Closed",
		"Uploading",
		"Capturing",
	}

	enum ActionId {
		Refresh,
		Capture,
		Flip,
		Test,
		_Count,
	}

	enum IconId {
		Capture,
		Stop,
		Refresh,
		Flip,
		_Count,
	}

	enum StatusPaneId {
		State,
		_Count,
	}

	static string_t const FirmwareFileName = __DIR__ "/firmware/serial-tap-pro.rpd";

protected:
	// usb

	State bindable m_state;
	io.UsbDevice* m_device;
	io.UsbInterface* m_iface;
	io.UsbEndpoint* m_outEndpoint;
	io.UsbEndpoint* m_inEndpoint;
	iox.FpgaUploader m_uploader;
	std.Buffer m_readBuffer;
	std.Buffer m_controlBuffer;
	SerialTapProDecoder m_decoder;

	SerialTapProMode bindable m_serialMode;
	uint_t m_baudRate;
	uint_t m_dataBits;
	io.SerialStopBits m_stopBits;
	io.SerialParity m_parity;
	uint_t m_outEpSyncId;
	uint_t m_inEpSyncId;

	// serial tap pro ui

	ui.SerialUi m_serialUi;
	ui.ComboBox* m_injectChannelCombo;
	ui.CheckBox* m_forwardCheckBox;

	// toolbar, status bar & menu

	ui.Action* m_actionTable[ActionId._Count];
	ui.Icon* m_iconTable[IconId._Count];
	ui.StatusPane* m_statusPaneTable[StatusPaneId._Count];
	ui.ComboBox* m_deviceCombo;

	// property grid

	ui.EnumProperty* m_deviceProp;
	ui.BoolProperty* m_flipProp;
	ui.BoolProperty* m_forwardProp;
	ui.BufferPropertySet m_bufferPropertySet;

	// information grid

	ui.StdSessionInfoSet m_stdSessionInfoSet;
	ui.ThroughputInfoSet m_throughputInfoSet;
	ui.ChecksumInfoSet m_checksumInfoSet;
	SerialTapProInfoSet m_serialTapProInfoSet;

	// ui reactor

	reactor m_uiReactor;
	sys.Timer m_statusTimer;

public:
	construct(doc.PluginHost* pluginHost);

	bool errorcode capture();
	void stopCapture(bool isGraceful = true);

	override void load(doc.Storage* storage);
	override void save(doc.Storage* storage);
	override void updateProperties();
	override errorcode bool applyProperties();
	override void restoreDefaultProperties();

	override size_t errorcode transmit(
		void const* p,
		size_t size
	);

	override bool errorcode connectSession() {
		return m_sessionConnectionState ? true : capture();
	}

	override void disconnectSession() {
		stopCapture();
	}

protected:
	void onCapture();

	void onDeviceComboEnter() {
		try capture();
	}

	void onBaudRateChanged();
	void onDataBitsChanged();
	void onParityChanged();
	void onStopBitsChanged();
	void onInjectChannelChanged();
	void onForwardChanged();
	void onDtrRtsChanged();

	void onFlip() {
		m_decoder.m_isFlipped = m_actionTable[ActionId.Flip].m_isChecked;
	}

	void onUpdateCompleted(bool result);

	void onInEndpointEvent(
		uint_t syncId,
		io.UsbEndpointEvents triggeredEvents
	);

	void onOutEndpointEvent(
		uint_t syncId,
		io.UsbEndpointEvents triggeredEvents
	);

	void onStatusTimer();
	void onTest();

	void createUi();
	void enumerateDevices();
	void waitInEndpointEvents();
	void waitOutEndpointEvents();
	bool errorcode startCapture();
	bool errorcode flushInEndpoint();
	SerialTapProControlFlags calcControl(SerialTapProControlFlags control = SerialTapProControlFlags.Start);
	bool errorcode setControl(SerialTapProControlFlags control);
	bool errorcode setBaudRate(uint_t baudRate);

	bool errorcode setBits(
		uint_t dataBits,
		io.SerialParity parity,
		io.SerialStopBits stopBits
	);

	uint16_t readRegister(SerialTapProRegister register);

	bool errorcode writeRegister(
		SerialTapProRegister register,
		uint16_t value
	);
}

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

SerialTapProSession.construct(doc.PluginHost* pluginHost) {
	basetype.construct(pluginHost);
	m_uploader.construct(pluginHost);
	m_decoder.construct(pluginHost.m_log.m_writer, m_serialTapProInfoSet);

	m_controlBuffer.setSize(SerialTapProUsb.ControlBufferSize);
	m_uploader.m_onUpdateCompleted += onUpdateCompleted;

	createUi();

	pluginHost.m_log.addSelectionProcessor(log.ThroughputCalcRangeProcessor.factory~(m_throughputInfoSet));
	pluginHost.m_log.addSelectionProcessor(log.ChecksumCalcRangeProcessor.factory~(m_checksumInfoSet));
}

void SerialTapProSession.createUi() {
	// toolbar

	m_iconTable[IconId.Capture] = new ui.Icon("images/capture.png");
	m_iconTable[IconId.Stop] = new ui.Icon("images/stop.png");
	m_iconTable[IconId.Refresh] = new ui.Icon("images/refresh.png");
	m_iconTable[IconId.Flip] = new ui.Icon("images/flip.png");

	m_pluginHost.m_toolBar.addLabel("Tap:");
	m_deviceCombo = m_pluginHost.m_toolBar.addComboBox(-1);
	m_deviceCombo.m_onReturnPressed += onDeviceComboEnter;

	m_actionTable[ActionId.Refresh]  = createAction("Re-enumerate Serial Tap Pro devices", m_iconTable[IconId.Refresh]);
	m_actionTable[ActionId.Refresh].m_onTriggered += enumerateDevices;

	m_actionTable[ActionId.Capture] = createAction("Capture", m_iconTable[IconId.Capture]);
	m_actionTable[ActionId.Capture].m_onTriggered += onCapture;
	m_actionTable[ActionId.Flip] = createAction("Flip DTE/DCE", m_iconTable[IconId.Flip]);
	m_actionTable[ActionId.Flip].m_isCheckable = true;
	m_actionTable[ActionId.Flip].m_onTriggered += onFlip;

	// m_actionTable[ActionId.Test] = createAction("Test");
	// m_actionTable[ActionId.Test].m_onTriggered += onTest;

	// status bar

	m_statusPaneTable[StatusPaneId.State] = m_pluginHost.m_statusBar.addPane(, 80);

	// property grid

	ui.GroupProperty* groupProp = m_pluginHost.m_propertyGrid.createGroupProperty(
		"Connection",
		"USB-specific connection settings"
	);

	m_deviceProp = m_pluginHost.m_propertyGrid.createEnumProperty(
		groupProp,,
		"Device",
		"Target USB device",
		null, 0
	);

	ui.FormLayout layout;

	ui.SerialUi.ItemId serialUiMask =
		ui.SerialUi.ItemId.BaudRate |
		ui.SerialUi.ItemId.DataBits |
		ui.SerialUi.ItemId.StopBits |
		ui.SerialUi.ItemId.Parity |
		ui.SerialUi.ItemId.ParityIgnore |
		ui.SerialUi.ItemId.Dtr |
		ui.SerialUi.ItemId.Rts;

	m_serialUi.createForm(layout, serialUiMask);
	m_serialUi.createProperties(m_pluginHost.m_propertyGrid, groupProp, serialUiMask);

	static ui.ComboItem const channelItems[] = {
		{ "D0", 0 },
		{ "D1", 1 },
	};

	ui.FormLayout injectLayout;

	m_injectChannelCombo = new ui.ComboBox(channelItems, countof(channelItems));
	injectLayout.addRow("Inject channel:", m_injectChannelCombo);

	m_forwardCheckBox = new ui.CheckBox("Forward D0 \u2194 D1");
	injectLayout.addRow(m_forwardCheckBox);

	ui.GroupBox injectGroup("RS485 inject", injectLayout);
	layout.addRow(injectGroup);

	ui.GroupBox groupBox("Serial Tap Pro settings", layout);
	m_pluginHost.createForm(groupBox);

	m_serialUi.m_baudRateCombo.m_onReturnPressed += onBaudRateChanged;
	bindingof(m_serialUi.m_baudRateCombo.m_currentIndex) += onBaudRateChanged;
	bindingof(m_serialUi.m_dataBitsCombo.m_currentIndex) += onDataBitsChanged;
	bindingof(m_serialUi.m_parityCombo.m_currentIndex) += onParityChanged;
	bindingof(m_serialUi.m_stopBitsCombo.m_currentIndex) += onStopBitsChanged;
	bindingof(m_injectChannelCombo.m_currentIndex) += onInjectChannelChanged;
	bindingof(m_forwardCheckBox.m_isChecked) += onForwardChanged;
	m_serialUi.m_dtrAction.m_onTriggered += onDtrRtsChanged;
	m_serialUi.m_rtsAction.m_onTriggered += onDtrRtsChanged;

	m_flipProp = m_pluginHost.m_propertyGrid.createBoolProperty(
		groupProp,,
		"Flip DTE/DCE",
		"Flip logical sides of the tap cable"
	);

	ui.BufferPropertySet.PropertyId ids =
		ui.BufferPropertySet.PropertyId.ReadParallelism |
		ui.BufferPropertySet.PropertyId.ReadBufferSize |
		ui.BufferPropertySet.PropertyId.NotifyReadBufferFull;

	m_bufferPropertySet.m_defaultReadParallelism = Defaults.ReadParallelism;
	m_bufferPropertySet.m_defaultReadBlockSize = Defaults.ReadBlockSize;
	m_bufferPropertySet.m_defaultReadBufferSize = Defaults.ReadBufferSize;
	m_bufferPropertySet.createPropertiesGrouped(m_pluginHost.m_propertyGrid,,, ids);

	// information grid

	ui.InformationGroup* infoGroup = m_pluginHost.m_informationGrid.createGroup("Serial Tap Pro");

	m_stdSessionInfoSet.create(m_pluginHost.m_txRxStats, m_pluginHost.m_informationGrid, infoGroup);
	m_serialTapProInfoSet.create(m_pluginHost.m_informationGrid, infoGroup);

	m_throughputInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);
	m_checksumInfoSet.createInformationValuesGrouped(m_pluginHost.m_informationGrid);

	m_pluginHost.m_propertyGrid.resizeNameColumnToContents();
	m_pluginHost.m_informationGrid.resizeNameColumnToContents();

	enumerateDevices();
	m_uiReactor.start();
}

void SerialTapProSession.onCapture() {
	if (m_state)
		stopCapture();
	else
		try capture();
}

void SerialTapProSession.onUpdateCompleted(bool result) {
	if (!result) {
		stopCapture();
		return;
	}

	startCapture();

catch:
	m_logWriter.writeLastError(SerialTapProLogRecordCode.CaptureError);
	stopCapture(false);
}

void SerialTapProSession.enumerateDevices() {
	m_deviceCombo.clear();

	io.UsbDevice* const* deviceArray = io.enumerateUsbDevicesNoDesc();
	size_t totalCount = dynamic countof(deviceArray);
	size_t actualCount = 0;

	ui.EnumPropertyOption* optionTable = new ui.EnumPropertyOption[totalCount];

	for (size_t i = 0; i < totalCount; i++) {
		io.UsbDevice* device = deviceArray[i];
		io.UsbDeviceDescriptor const* deviceDesc = device.m_deviceDescriptor;

		if (deviceDesc.m_vendorId != SerialTapProUsb.VendorId ||
			deviceDesc.m_productId != SerialTapProUsb.ProductId)
			continue;

		string_t text = $"@%(1;03d):%(2;03d) IO Ninja Serial Tap Pro" (
			device.m_bus,
			device.m_address
		);

		m_deviceCombo.addItem(text, device);

		optionTable[actualCount].m_text = text;
		optionTable[actualCount].m_value = device;
		actualCount++;
	}

	m_deviceProp.setOptions(optionTable, actualCount);
}

bool errorcode SerialTapProSession.capture() {
	stopCapture();

	if (m_deviceCombo.m_currentIndex == -1)
		return true;

	startSession();
	m_device = m_deviceCombo.m_currentData;
	m_device.open();
	m_logWriter.write(SerialTapProLogRecordCode.DeviceOpened, m_deviceCombo.m_currentText);
	return startCapture();

//	m_uploader.update(m_device, FirmwareFileName, FpgaUploadBaseIndex);

catch:
	m_logWriter.writeLastError(SerialTapProLogRecordCode.CaptureError);
	stopCapture(false);
	return false;
}

bool errorcode SerialTapProSession.startCapture() {
	m_iface = m_device.claimInterface(0);
	writeRegister(SerialTapProRegister.Control, 0);
	flushInEndpoint();

	m_outEndpoint = m_iface.openEndpoint(SerialTapProUsb.OutEndpoint, true);
	m_inEndpoint = m_iface.openEndpoint(SerialTapProUsb.InEndpoint, true);
	m_inEndpoint.m_readParallelism = m_bufferPropertySet.m_readParallelismProp.m_value;
	m_inEndpoint.m_readBlockSize = SerialTapProUsb.BulkSize;
	m_inEndpoint.m_readBufferSize = m_bufferPropertySet.m_readBufferSizeProp.m_value;
	m_inEndpoint.m_options &= ~io.UsbEndpointOptions.KeepReadBlockSize;
	m_inEndpoint.unsuspend();

	uint_t baudRate = m_serialUi.m_baudRate;
	uint_t dataBits = m_serialUi.m_dataBits;
	io.SerialStopBits stopBits = m_serialUi.m_stopBits;
	io.SerialParity parity = m_serialUi.m_parity;

	m_logWriter.write($"DEBUG: status: 0x%04x"(readRegister(SerialTapProRegister.Status)));
	m_logWriter.write(log.StdRecordCode.Break);

	setBaudRate(baudRate);
	setBits(dataBits, parity, stopBits);

	SerialTapProMode mode = (SerialTapProMode)(readRegister(SerialTapProRegister.Status) & SerialTapProMode.Mask);

	m_serialMode = mode;
	m_baudRate = baudRate;
	m_dataBits = dataBits;
	m_parity = parity;
	m_stopBits = stopBits;

	writeRegister(SerialTapProRegister.Time2, 0);
	writeRegister(SerialTapProRegister.Time1, 0);
	writeRegister(SerialTapProRegister.Time0, 0);
	waitInEndpointEvents();
	setControl(calcControl());

	m_logWriter.write(SerialTapProLogRecordCode.CaptureStarted, &mode, sizeof(mode));

	SerialTapProStatusLines lines = (SerialTapProStatusLines)readRegister(SerialTapProRegister.StatusLines);
	m_serialTapProInfoSet.setMode(mode);
	m_serialTapProInfoSet.setOverflows(0);
	m_serialTapProInfoSet.updateStatusLines(lines);
	m_decoder.reset(mode, lines);

	SerialTapProStatusLineChangedParams params;
	params.m_lines = lines;
	params.m_mask = (SerialTapProStatusLines)-1;
	m_logWriter.write(SerialTapProLogRecordCode.StatusLineChanged, &params, sizeof(params));

	m_stdSessionInfoSet.startSession(m_pluginHost.m_mainThreadScheduler);
	m_statusTimer.startPeriodicTimer(onStatusTimer, 500);
	m_state = State.Capturing;
	m_isTransmitEnabled = true;
	return true;
}

bool errorcode SerialTapProSession.flushInEndpoint() {
	io.UsbEndpoint* ep = m_iface.openEndpoint(SerialTapProUsb.InEndpoint, true);

	ep.m_readParallelism = 1;
	ep.m_readBlockSize = SerialTapProUsb.BulkSize;
	ep.m_readBufferSize = CypressBufferSize;
	ep.m_options &= ~io.UsbEndpointOptions.KeepReadBlockSize;
	ep.unsuspend();

	for (;;) {
		ep.blockingWait(io.UsbEndpointEvents.IncomingData, CypressClearBufferTimeout);
		size_t size = ep.read(m_readBuffer.m_p, m_readBuffer.m_size);
		if (!size)
			break;

		// m_logWriter.write(log.StdRecordCode.PlainText, $"Cypress buffer clear received: $size");
		// m_logWriter.write(log.StdRecordCode.Bin, m_readBuffer.m_p, size);
	}

	ep.close();
	m_logWriter.write(SerialTapProLogRecordCode.CypressBufferCleared);
	return true;
}

SerialTapProControlFlags SerialTapProSession.calcControl(SerialTapProControlFlags control) {
	if (m_injectChannelCombo.m_currentIndex)
		control |= SerialTapProControlFlags.InjectChannel;

	if (m_forwardCheckBox.m_isChecked)
		control |= SerialTapProControlFlags.Forward;

	if (m_serialUi.m_dtr)
		control |= SerialTapProControlFlags.Dtr;

	if (m_serialUi.m_rts)
		control |= SerialTapProControlFlags.Rts;

	return control;
}

bool errorcode SerialTapProSession.setControl(SerialTapProControlFlags control) {
	writeRegister(SerialTapProRegister.Control, control);

	control = (SerialTapProControlFlags)readRegister(SerialTapProRegister.Control);
	m_logWriter.write($"DEBUG: control: 0x%04x"(control));
	m_logWriter.write(log.StdRecordCode.Break);
	return true;
}

uint_t gcd(
	uint_t a,
	uint_t b
) {
	while (b) {
		uint_t r = a % b;
		a = b;
		b = r;
	}

	return a;
}

bool errorcode SerialTapProSession.setBaudRate(uint_t baudRate) {
	uint_t baudRate16 = baudRate * 16;
	uint_t freqBaudGcd = gcd(FpgaFreq, baudRate16);
	uint16_t baudFreq = baudRate16 / freqBaudGcd;
	uint16_t baudLimit = FpgaFreq / freqBaudGcd - baudFreq;
	writeRegister(SerialTapProRegister.BaudFreq, baudFreq);
	writeRegister(SerialTapProRegister.BaudLimit, baudLimit);

	baudFreq = readRegister(SerialTapProRegister.BaudFreq);
	baudLimit = readRegister(SerialTapProRegister.BaudLimit);
	m_logWriter.write($"DEBUG: baud: %d freq: 0x%04x limit: 0x%04x"(baudRate, baudFreq, baudLimit));
	m_logWriter.write(log.StdRecordCode.Break);
	return true;
}

bool errorcode SerialTapProSession.setBits(
	uint_t dataBits,
	io.SerialParity parity,
	io.SerialStopBits stopBits
) {
	SerialTapProBits bits;
	bits.m_dataBits = dataBits;
	bits.m_parity = parity;
	bits.m_stopBits = stopBits;
	writeRegister(SerialTapProRegister.Bits, bits.m_value);

	bits.m_value = readRegister(SerialTapProRegister.Bits);
	m_logWriter.write($"DEBUG: data: %d parity: %d stop: %d value: 0x%04x"(dataBits, parity, stopBits, bits.m_value));
	m_logWriter.write(log.StdRecordCode.Break);
	return true;
}

uint16_t SerialTapProSession.readRegister(SerialTapProRegister register) {
	*(uint16_t bigendian*)m_controlBuffer.m_p = 0; // zero it first

	size_t size = m_device.controlTransfer(
		SerialTapProUsb.ControlInRequestType,
		SerialTapProControlRequestCode.ReadRegister,
		0,
		register,
		m_controlBuffer.m_p,
		m_controlBuffer.m_size
	);

	return *(uint16_t bigendian const*)m_controlBuffer.m_p;
}

bool errorcode SerialTapProSession.writeRegister(
	SerialTapProRegister register,
	uint16_t value
) {
	*(uint16_t bigendian*)m_controlBuffer.m_p = value;

	m_device.controlTransfer(
		SerialTapProUsb.ControlOutRequestType,
		SerialTapProControlRequestCode.WriteRegister,
		0,
		register,
		m_controlBuffer.m_p,
		sizeof(value)
	);

	return true;
}

void SerialTapProSession.stopCapture(bool isGraceful) {
	m_statusTimer.stop();

	if (m_device && isGraceful)
	 	writeRegister(SerialTapProRegister.Control, 0);

	if (m_inEndpoint) {
		m_inEndpoint.close();
		m_inEndpoint = null;
	}

	if (m_outEndpoint) {
		m_outEndpoint.close();
		m_outEndpoint = null;
	}

	if (m_iface) {
		if (isGraceful)
			flushInEndpoint();

		m_iface.release();
		m_iface = null;
	}

	if (m_device) {
		m_device.close();
		m_device = null;
	}

	if (m_state) {
		m_stdSessionInfoSet.endSession();
		m_logWriter.write(SerialTapProLogRecordCode.CaptureStopped);
		m_state = State.Closed;
	}

	m_uploader.cancel();
	m_isTransmitEnabled = false;
	m_outEpSyncId++;
	m_inEpSyncId++;
}

void SerialTapProSession.waitOutEndpointEvents() {
	io.UsbEndpointEvents eventMask = io.UsbEndpointEvents.IoError;

	if (!m_isTransmitEnabled)
		eventMask |= io.UsbEndpointEvents.WriteBufferReady;

	m_outEndpoint.wait(eventMask, onOutEndpointEvent~(++m_outEpSyncId) @ m_pluginHost.m_mainThreadScheduler);
}

void SerialTapProSession.waitInEndpointEvents() {
	io.UsbEndpointEvents eventMask =
		io.UsbEndpointEvents.IoError |
		io.UsbEndpointEvents.ReadBufferFull |
		io.UsbEndpointEvents.IncomingData;

	m_inEndpoint.wait(eventMask, onInEndpointEvent~(++m_inEpSyncId) @ m_pluginHost.m_mainThreadScheduler);
}

void SerialTapProSession.onOutEndpointEvent(
	uint_t syncId,
	io.UsbEndpointEvents triggeredEvents
) {
	if (syncId != m_outEpSyncId)
		return;

	if (triggeredEvents & io.UsbEndpointEvents.IoError) {
		m_logWriter.write(log.StdRecordCode.Error, m_outEndpoint.m_ioError);
		stopCapture(false);
		return;
	}

	if (triggeredEvents & io.UsbEndpointEvents.WriteBufferReady)
		m_isTransmitEnabled = true;

	waitOutEndpointEvents();
}

void SerialTapProSession.onInEndpointEvent(
	uint_t syncId,
	io.UsbEndpointEvents triggeredEvents
) {
	if (syncId != m_inEpSyncId)
		return;

	if (triggeredEvents & io.UsbEndpointEvents.IoError) {
		m_logWriter.write(log.StdRecordCode.Error, m_inEndpoint.m_ioError);
		stopCapture(false);
		return;
	}

	if (triggeredEvents & io.UsbEndpointEvents.IncomingData) {
		size_t size = m_inEndpoint.read(m_readBuffer.m_p, m_readBuffer.m_size);
		m_decoder.decode(m_readBuffer.m_p, size);
		// m_decoder_legacy.decode(m_readBuffer.m_p, size);
	}

	waitInEndpointEvents();
}

void SerialTapProSession.load(doc.Storage* storage) {
	m_serialUi.load(storage);
	m_injectChannelCombo.m_currentIndex = storage.readBool("injectChannel");
	m_forwardCheckBox.m_isChecked = storage.readBool("forward");

	m_deviceCombo.m_currentIndex  = storage.readInt("deviceIdx");
	m_actionTable[ActionId.Flip].m_isChecked = storage.readBool("flipDteDce", false);
	m_bufferPropertySet.load(storage);
	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);
}

void SerialTapProSession.save(doc.Storage* storage) {
	m_serialUi.save(storage);
	storage.writeInt("injectChannel", m_injectChannelCombo.m_currentIndex);
	storage.writeBool("forward", m_forwardCheckBox.m_isChecked);
	storage.writeInt("deviceIdx", m_deviceCombo.m_currentIndex);
	storage.writeBool("flipDteDce", m_actionTable[ActionId.Flip].m_isChecked);
	m_bufferPropertySet.save(storage);
}

void SerialTapProSession.updateProperties() {
	m_serialUi.updateProperties();

	m_deviceProp.m_currentIndex = m_deviceCombo.m_currentIndex;
}

bool errorcode SerialTapProSession.applyProperties() {
	m_serialUi.applyProperties();

	m_deviceCombo.m_currentIndex = m_deviceProp.m_currentIndex;
	m_actionTable[ActionId.Flip].m_isChecked = m_flipProp.m_value;

	m_readBuffer.detach(); // drop buffer, so we re-allocate each time
	m_readBuffer.setSize(m_bufferPropertySet.m_readBufferSizeProp.m_value);

	if (m_state != State.Capturing)
		return true;

	uint_t baudRate = m_serialUi.m_baudRate;
	uint_t dataBits = m_serialUi.m_dataBits;
	io.SerialStopBits stopBits = m_serialUi.m_stopBits;
	io.SerialParity parity = m_serialUi.m_parity;

	if (m_baudRate != baudRate) {
		setBaudRate(baudRate);
		m_logWriter.write(SerialTapProLogRecordCode.BaudRateChanged, &baudRate, sizeof(baudRate));
		m_baudRate = baudRate;
	}

	if (
		m_dataBits != dataBits ||
		m_parity != parity ||
		m_stopBits != stopBits
	) {
		setBits(dataBits, parity, stopBits);
		if (m_dataBits != dataBits)
			m_logWriter.write(SerialTapProLogRecordCode.DataBitsChanged, &dataBits, sizeof(dataBits));

		if (m_parity != parity)
			m_logWriter.write(SerialTapProLogRecordCode.ParityChanged, &parity, sizeof(parity));

		if (m_stopBits != stopBits)
			m_logWriter.write(SerialTapProLogRecordCode.StopBitsChanged, &stopBits, sizeof(stopBits));

		m_dataBits = dataBits;
		m_parity = parity;
		m_stopBits = stopBits;
	}

	m_inEndpoint.m_readParallelism = m_bufferPropertySet.m_readParallelismProp.m_value;
	m_inEndpoint.m_readBlockSize = m_bufferPropertySet.m_readBlockSizeProp.m_value;
	m_inEndpoint.m_readBufferSize = m_bufferPropertySet.m_readBufferSizeProp.m_value;
	return true;

catch:
	m_logWriter.writeLastError(log.StdRecordCode.Error);
	return false;
}

void SerialTapProSession.restoreDefaultProperties() {
	m_serialUi.restoreDefaultProperties();
	m_flipProp.m_value = false;
	m_bufferPropertySet.restoreDefaults();
}

size_t errorcode SerialTapProSession.transmit(
	void const* p,
	size_t size
) {
	if (m_state != State.Capturing) {
		std.setError("not connected");
		return -1;
	}

	size_t result = m_outEndpoint.write(p, size);
	if (result < size && m_isTransmitEnabled) {
		m_isTransmitEnabled = false;
		waitOutEndpointEvents();
	}

	// don't write it to log -- the tap will decode and report the injected data
	return result;
}

void SerialTapProSession.onBaudRateChanged() {
	if (m_state != State.Capturing)
		return;

	uint_t baudRate = m_serialUi.m_baudRate;
	if (baudRate == m_baudRate)
		return;

	setBaudRate(baudRate);
	m_logWriter.write(SerialTapProLogRecordCode.BaudRateChanged, &baudRate, sizeof(baudRate));
	m_baudRate = baudRate;

catch:
	m_logWriter.writeLastError(log.StdRecordCode.Error);
}

void SerialTapProSession.onDataBitsChanged() {
	if (m_state != State.Capturing)
		return;

	uint_t dataBits = m_serialUi.m_dataBits;
	if (dataBits == m_dataBits)
		return;

	setBits(dataBits, m_parity, m_stopBits);
	m_logWriter.write(SerialTapProLogRecordCode.DataBitsChanged, &dataBits, sizeof(dataBits));
	m_dataBits = dataBits;

catch:
	m_logWriter.writeLastError(log.StdRecordCode.Error);
}

void SerialTapProSession.onParityChanged() {
	if (m_state != State.Capturing)
		return;

	io.SerialParity parity = m_serialUi.m_parity;
	if (parity == m_parity)
		return;

	setBits(m_dataBits, parity, m_stopBits);
	m_logWriter.write(SerialTapProLogRecordCode.ParityChanged, &parity, sizeof(parity));
	m_parity = parity;

catch:
	m_logWriter.writeLastError(log.StdRecordCode.Error);
}

void SerialTapProSession.onStopBitsChanged() {
	if (m_state != State.Capturing)
		return;

	io.SerialStopBits stopBits = m_serialUi.m_stopBits;
	if (stopBits == m_stopBits)
		return;

	setBits(m_dataBits, m_parity, stopBits);
	m_logWriter.write(SerialTapProLogRecordCode.StopBitsChanged, &stopBits, sizeof(stopBits));
	m_stopBits = stopBits;

catch:
	m_logWriter.writeLastError(log.StdRecordCode.Error);
}

void SerialTapProSession.onDtrRtsChanged() {
	if (m_state != State.Capturing)
		return;

	setControl(calcControl());

catch:
	m_logWriter.writeLastError(log.StdRecordCode.Error);
}

void SerialTapProSession.onInjectChannelChanged() {
	if (m_state != State.Capturing)
		return;

	setControl(calcControl());

	uint8_t channel = m_injectChannelCombo.m_currentIndex;
	m_logWriter.write(SerialTapProLogRecordCode.InjectChannelChanged, &channel, sizeof(channel));

catch:
	m_logWriter.writeLastError(log.StdRecordCode.Error);
}

void SerialTapProSession.onForwardChanged() {
	if (m_state != State.Capturing)
		return;

	setControl(calcControl());

	bool forward = m_forwardCheckBox.m_isChecked;
	m_logWriter.write(SerialTapProLogRecordCode.ForwardChanged, &forward, sizeof(forward));

catch:
	m_logWriter.writeLastError(log.StdRecordCode.Error);
}

void SerialTapProSession.onStatusTimer() {
	uint_t status = readRegister(SerialTapProRegister.Status);
	SerialTapProMode mode = (SerialTapProMode)(status & SerialTapProMode.Mask);
	if (m_serialMode != mode) {
		m_serialMode = mode;
		// m_serialTapProInfoSet.setMode(mode);
		// m_logWriter.write(SerialTapProLogRecordCode.ModeChanged, &mode, sizeof(mode));
	}

	// maybe more
}

void SerialTapProSession.onTest() {
	static char data[] = { 0x03, 0xe2, 0x8a, 0x99, 0x1e, 0x74, 0x00 };
	m_logWriter.write(log.StdRecordCode.Bin, data, sizeof(data));
	m_decoder.decode(data, sizeof(data));
}

reactor SerialTapProSession.m_uiReactor {
	m_title = $"Serial Tap Pro $(m_deviceCombo.m_currentText)";

	m_sessionConnectionState =
		m_state == State.Capturing ? SessionConnectionState.Connected :
		m_state == State.Closed ? SessionConnectionState.Disconnected :
		SessionConnectionState.Connecting;

	m_actionTable[ActionId.Capture].m_text = m_state ? "Stop capture" : "Capture";
	m_actionTable[ActionId.Capture].m_icon = m_iconTable[m_state ? IconId.Stop : IconId.Capture];
	m_statusPaneTable[StatusPaneId.State].m_text = m_statusTextTable[m_state];
	m_serialUi.m_dtrAction.m_isEnabled =
	m_serialUi.m_dtrProp.m_isEnabled =
	m_serialUi.m_rtsAction.m_isEnabled =
	m_serialUi.m_rtsProp.m_isEnabled = m_state == State.Capturing;
	m_injectChannelCombo.m_isEnabled =
	m_forwardCheckBox.m_isEnabled = m_state == State.Capturing && m_serialMode == SerialTapProMode.Rs485;

	m_serialTapProInfoSet.m_isEnabled = m_state == State.Capturing;
	m_serialTapProInfoSet.setMode(m_serialMode);
}

//..............................................................................
